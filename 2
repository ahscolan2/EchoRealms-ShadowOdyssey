    // Build initial biome and branching path
    this.buildLevel(this.level);
    // Player
    this.player = new Player(this, 80, 460);
    // Enemy group
    this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true });
    this.spawnEnemies();
    // Collectibles
    this.orbs = this.physics.add.group();
    this.keys = this.physics.add.group();
    this.shards = this.physics.add.group();
    this.spawnCollectibles();
    // UI
    this.createUI();
    // Collisions
    this.physics.add.collider(this.player, this.platforms, () => {}, null, this);
    this.physics.add.collider(this.enemies, this.platforms);
    this.physics.add.overlap(this.player, this.enemies, () => this.player.takeDamage(1));
    this.physics.add.overlap(this.player, this.orbs, (p, orb) => {
      orb.destroy();
      this.score += 10;
      this.sound.play('sfx_pick', { volume: 0.4 });
      this.events.emit('ui:score', this.score);
    });
    this.physics.add.overlap(this.player, this.shards, (p, s) => {
      s.destroy();
      this.player.inventory.shards++;
      this.events.emit('ui:inventory', this.player.inventory);
      this.sound.play('sfx_pick', { volume: 0.4, detune: 300 });
    });
    this.physics.add.overlap(this.player, this.keys, (p, k) => {
      k.destroy();
      this.player.inventory.keys++;
      this.events.emit('ui:inventory', this.player.inventory);
      this.sound.play('sfx_pick', { volume: 0.5, detune: -150 });
    });
    // Switch activation
    this.switchSensors = this.physics.add.group();
    this.switches.forEach(sw => {
      const sensor = this.switchSensors.create(sw.x, sw.y, null);
      sensor.body.setAllowGravity(false);
      sensor.setCircle(18);
      sensor.setVisible(false);
    });
    this.physics.add.overlap(this.player, this.switchSensors, (p, sensor) => {
      const idx = this.switchSensors.getChildren().indexOf(sensor);
      const sw = this.switches[idx];
      if (sw && !sw.activated) sw.activate();
    });
    // Door listening
    this.switchProgress = 0;
    this.events.on('puzzle:switch', () => {
      this.switchProgress++;
      if (this.switchProgress >= this.switches.length) {
        // Open all doors in current level branch
        this.doors.forEach(d => d.open());
      }
    });

    // Physics debug toggle key
    this.debugKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F3);

    // Controls
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys({ W: 'W', A: 'A', S: 'S', D: 'D', SHIFT: 'SHIFT' });

    // Camera
    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
    this.cameras.main.setZoom(1.2);
  }

  createUI() {
    // Health bar hearts
    this.ui = {};
    this.ui.hearts = this.add.group();
    this.updateHearts(this.player.health, this.player.maxHealth);

    // Inventory + score text
    this.ui.text = this.add.text(10, 24, '', { fontFamily: 'monospace', fontSize: 12, color: '#cfe9ff' }).setScrollFactor(0);
    this.events.on('ui:score', () => this.refreshUI());
    this.events.on('ui:inventory', () => this.refreshUI());
    this.events.on('player:health', (h, m) => this.updateHearts(h, m));
    this.refreshUI();
  }

  updateHearts(h, m) {
    this.ui.hearts.clear(true, true);
    for (let i = 0; i < m; i++) {
      const heart = this.add.image(10 + i * 14, 10, 'ui_heart').setOrigin(0, 0).setScrollFactor(0);
      heart.setTint(i < h ? 0xff4d6d : 0x23303a);
      this.ui.hearts.add(heart);
    }
  }

  refreshUI() {
    const inv = this.player.inventory;
    this.ui.text.setText(`Shards: ${inv.shards}  Keys: ${inv.keys}  Score: ${this.score}`);
  }

  spawnCollectibles() {
    const orbPositions = [
      { x: 220, y: 380 }, { x: 260, y: 360 }, { x: 300, y: 340 },
      { x: 720, y: 320 }, { x: 760, y: 300 }, { x: 1200, y: 260 },
    ];
    orbPositions.forEach(p => this.orbs.create(p.x, p.y, 'shard'));

    this.keys.create(560, 420, 'key');
    this.shards.create(980, 320, 'shard');
  }

  spawnEnemies() {
    const e1 = new Enemy(this, 520, 460);
    e1.setTexture('enemy-shadow');
    e1.setPatrolPoints([{ x: 520, y: 460 }, { x: 680, y: 460 }]);
    this.enemies.add(e1);

    const e2 = new Enemy(this, 1100, 420);
    e2.setTexture('enemy-shadow');
    e2.setPatrolPoints([{ x: 1040, y: 420 }, { x: 1240, y: 420 }]);
    this.enemies.add(e2);
  }

  buildLevel(id) {
    // Clear previous
    this.platforms.clear(true, true);
    this.doors.length = 0;
    this.switches.length = 0;

    // Ground
    for (let x = 0; x <= 2000; x += 400) {
      this.platforms.create(x + 200, 584, 'ground').refreshBody();
    }

    // Biome variations + branching
    if (id % 2 === 0) {
      // Ruins biome
      this.add.text(20, 560, 'Ruins', { font: '12px monospace', color: '#788' }).setScrollFactor(0);
      this.platforms.create(300, 480, 'platform').refreshBody();
      this.platforms.create(360, 440, 'platform').refreshBody();
      this.platforms.create(420, 400, 'platform').refreshBody();

      // Branch: Upper path (requires double jump/wall)
      this.platforms.create(700, 360, 'platform').refreshBody();
      this.platforms.create(760, 320, 'platform').refreshBody();

      // Lower path with door locked by switches
      const door = new PuzzleDoor(this, 900, 520, 28, 80);
      this.doors.push(door);
      const sw1 = new PuzzleSwitch(this, 820, 540);
      const sw2 = new PuzzleSwitch(this, 980, 540);
      this.switches.push(sw1, sw2);
    } else {
      // Cavern biome
      this.add.text(20, 560, 'Cavern', { font: '12px monospace', color: '#887' }).setScrollFactor(0);
      this.platforms.create(260, 520, 'platform').refreshBody();
      this.platforms.create(420, 460, 'platform').refreshBody();
      this.platforms.create(580, 420, 'platform').refreshBody();
      this.platforms.create(820, 380, 'platform').refreshBody();

      const door = new PuzzleDoor(this, 1200, 500, 28, 100);
      this.doors.push(door);
      const sw1 = new PuzzleSwitch(this, 1120, 540);
      const sw2 = new PuzzleSwitch(this, 1280, 540);
      const sw3 = new PuzzleSwitch(this, 1400, 540);
      this.switches.push(sw1, sw2, sw3);
    }
  }

  update(time, delta) {
    // Toggle debug physics bounds
    if (Phaser.Input.Keyboard.JustDown(this.debugKey)) {
      const dbg = this.physics.world.drawDebug;
      this.physics.world.drawDebug = !dbg;
      this.physics.world.debugGraphic.clear();
    }

    this.player.handleInput(this.cursors, this.wasd);

    // Enemy AI updates
    this.enemies.children.iterate(e => {
      if (e) e.updateAI(this.player, this.platforms);
    });

    // Branching progression: if player reaches far right, advance level
    if (this.player.x > 1920) {
      this.level++;
      this.buildLevel(this.level);
      this.player.setPosition(80, 460);
      this.spawnEnemies();
      this.spawnCollectibles();
    }
  }

  onPlayerDeath() {
    this.physics.pause();
    const t = this.add.text(this.cameras.main.worldView.centerX, this.cameras.main.worldView.centerY,
      'SHADOW CONSUMED YOU!\nPress R to retry', { fontSize: '24px', color: '#ff4d6d', fontFamily: 'monospace', align: 'center' }).setOrigin(0.5);
    this.input.keyboard.once('keydown-R', () => {
      this.scene.restart();
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: 'phaser-game',
  backgroundColor: '#0a0a0a',
  physics: { default: 'arcade', arcade: { gravity: { y: 480 }, debug: false } },
  scene: [MainScene]
};

const game = new Phaser.Game(config);

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { Player, Enemy, PuzzleDoor, PuzzleSwitch, MainScene, config, game };
}

console.log('EchoRealms: Shadow Odyssey enhanced build loaded. Controls: Arrows/WASD + Shift to dash.');
