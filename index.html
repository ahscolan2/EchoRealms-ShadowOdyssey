<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EchoRealms: Shadow Odyssey - Full Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
            color: #ffffff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameContainer {
            position: relative;
            background: linear-gradient(to bottom, #001122, #003366);
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #001a33, #002266);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            font-size: 14px;
        }
        .bar {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        #healthBar .bar-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
        #energyBar .bar-fill { background: linear-gradient(90deg, #4444ff, #6666ff); }
        .stats {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid #444;
        }
        .screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .screen.hidden { display: none; }
        .screen h1 {
            font-size: 2.5em;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            margin-bottom: 20px;
        }
        .screen h2 {
            font-size: 1.8em;
            color: #ffff00;
            margin-bottom: 15px;
        }
        .screen p {
            margin: 5px 0;
            color: #cccccc;
        }
        button {
            padding: 12px 25px;
            font-size: 1.1em;
            background: linear-gradient(45deg, #006666, #00aaaa);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(45deg, #008888, #00cccc);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 170, 170, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="healthBar" class="bar">
                <div class="bar-fill" style="width: 100%"></div>
            </div>
            <div id="energyBar" class="bar">
                <div class="bar-fill" style="width: 100%"></div>
            </div>
            <div class="stats">
                <div>Level: <span id="level">1</span></div>
                <div>Orbs: <span id="orbs">0</span>/5</div>
                <div>Score: <span id="score">0</span></div>
                <div id="comboDisplay" style="color: #ffaa00; font-weight: bold; display: none;">Combo: <span id="combo">0</span>x</div>
            </div>
        </div>
        <div class="controls">
            <strong>Controls:</strong><br>
            WASD/Arrows - Move<br>
            W/Space - Jump (3x)<br>
            X - Echo Dash<br>
            C - Time Slow<br>
            S+Down - Ground Slam
        </div>
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <!-- Screens -->
        <div id="startScreen" class="screen">
            <h1>EchoRealms: Shadow Odyssey</h1>
            <h2>Full Edition - 12 Levels</h2>
            <div style="text-align: center; margin: 20px;">
                <p><strong>Advanced Movement System:</strong></p>
                <p>Triple Jump • Echo Phase-Dash • Time Slow • Ground Slam</p>
                <p><strong>Multiple Biomes:</strong></p>
                <p>Shadow Realm • Forest Kingdom • Crystal Caves • Boss Arena</p>
                <p><strong>Epic Boss Battle:</strong></p>
                <p>Multi-phase Shadow King with unique attack patterns</p>
            </div>
            <button onclick="startGame()">Begin Odyssey (Story Mode)</button>
            <button onclick="startEndlessMode()" style="background: linear-gradient(45deg, #884400, #aa6622);">Endless Mode</button>
            <p style="margin-top: 10px; color: #888; font-size: 0.9em;">High Score: <span id="startHighScore">0</span></p>
        </div>
        
        <div id="gameOverScreen" class="screen hidden">
            <h1>Game Over</h1>
            <p>The shadows have consumed you...</p>
            <button onclick="restartGame()">Try Again</button>
        </div>
        
        <div id="victoryScreen" class="screen hidden">
            <h1>Victory!</h1>
            <p>You have conquered the Shadow Odyssey!</p>
            <p>All 12 levels cleared and Shadow King defeated!</p>
            <p id="finalScore" style="font-size: 1.3em; color: #ffdd00; margin-top: 15px;"></p>
            <p id="highScoreDisplay" style="color: #00ff88;"></p>
            <button onclick="restartGame()">Play Again</button>
        </div>
        
        <div id="levelCompleteScreen" class="screen hidden">
            <h1>Level Complete!</h1>
            <p id="levelCompleteText">Moving to next biome...</p>
            <button onclick="nextLevel()">Continue</button>
        </div>
        
        <div id="settingsScreen" class="screen hidden">
            <h1>Settings</h1>
            <div style="text-align: left; max-width: 400px; margin: 20px auto;">
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 8px;">SFX Volume: <span id="sfxVolumeValue">70%</span></label>
                    <input type="range" id="sfxVolumeSlider" min="0" max="100" value="70" style="width: 100%;">
                </div>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="checkbox" id="showTutorial" checked> Show Tutorial Hints
                    </label>
                </div>
                <div style="margin: 20px 0;">
                    <button onclick="resetProgress()" style="background: linear-gradient(45deg, #aa4444, #cc6666);">Reset Progress</button>
                </div>
            </div>
            <button onclick="closeSettings()">Back to Game</button>
        </div>
        
        <div id="tutorialOverlay" style="position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 15px 25px; border-radius: 10px; border: 2px solid #00ffff; z-index: 1500; display: none; max-width: 500px;">
            <p id="tutorialText" style="margin: 0; color: #ffffff; font-size: 14px; text-align: center;"></p>
        </div>
        
        <button id="settingsButton" onclick="openSettings()" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); padding: 8px 16px; font-size: 0.9em; z-index: 500;">⚙️ Settings</button>
    </div>

    <script>
        // Complete EchoRealms: Shadow Odyssey Game Engine
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.gameState = 'start'; // start, playing, paused, gameOver, victory
                this.currentLevel = 1;
                this.maxLevel = 12; // Expanded from 4 to 12 levels
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('echoRealmsHighScore') || '0');
                this.achievements = JSON.parse(localStorage.getItem('echoRealmsAchievements') || '[]');
                this.settings = JSON.parse(localStorage.getItem('echoRealmsSettings') || '{"sfxVolume":0.7,"musicVolume":0.5,"showTutorial":true}');
                
                // Combo system
                this.combo = 0;
                this.comboTimer = 0;
                this.comboMultiplier = 1;
                
                // Endless mode
                this.endlessMode = false;
                this.endlessLevel = 0;
                this.endlessDifficulty = 1;
                
                // Show high score on start screen
                document.getElementById('startHighScore').textContent = this.highScore;
                
                // Input
                this.keys = {};
                this.setupInput();
                
                // Game objects
                this.player = new Player(50, 450);
                this.platforms = [];
                this.movingPlatforms = [];
                this.hazards = [];
                this.enemies = [];
                this.collectibles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                // Camera with deadzone
                this.camera = { x: 0, y: 0, deadzone: 200 };
                this.screenShake = { x: 0, y: 0, intensity: 0 };
                
                // Parallax layers
                this.parallaxLayers = [];
                
                // Audio system
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.soundEnabled = this.settings.sfxVolume > 0;
                
                // Tutorial system
                this.tutorialShown = {
                    welcome: false,
                    jump: false,
                    dash: false,
                    enemy: false,
                    collectible: false
                };
                
                // Load first level
                this.loadLevel(1);
                
                // Start game loop
                this.lastTime = performance.now();
                this.gameLoop();
            }
            
            setupInput() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key.toLowerCase() === 'r' && this.gameState === 'playing') {
                        this.restartLevel();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }
            
            loadLevel(level) {
                this.currentLevel = level;
                this.platforms = [];
                this.movingPlatforms = [];
                this.hazards = [];
                this.enemies = [];
                this.collectibles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                // Create parallax background layers for this biome
                this.createParallaxLayers();
                
                // Reset player
                this.player.x = 50;
                this.player.y = 450;
                this.player.vx = 0;
                this.player.vy = 0;
                this.player.health = this.player.maxHealth;
                this.player.energy = this.player.maxEnergy;
                
                switch(level) {
                    case 1: this.loadShadowRealm1(); break;
                    case 2: this.loadShadowRealm2(); break;
                    case 3: this.loadShadowRealm3(); break;
                    case 4: this.loadForestKingdom1(); break;
                    case 5: this.loadForestKingdom2(); break;
                    case 6: this.loadForestKingdom3(); break;
                    case 7: this.loadCrystalCaves1(); break;
                    case 8: this.loadCrystalCaves2(); break;
                    case 9: this.loadCrystalCaves3(); break;
                    case 10: this.loadBossArena1(); break;
                    case 11: this.loadBossArena2(); break;
                    case 12: this.loadFinalBoss(); break;
                }
                
                this.updateUI();
            }
            
            // ENDLESS MODE - Procedurally generated levels
            loadEndlessLevel() {
                this.endlessLevel++;
                this.currentLevel = this.endlessLevel;
                this.endlessDifficulty = 1 + (this.endlessLevel * 0.15);
                
                // Clear arrays
                this.platforms = [];
                this.movingPlatforms = [];
                this.hazards = [];
                this.enemies = [];
                this.collectibles = [];
                this.particles = [];
                this.floatingTexts = [];
                
                // Reset player
                this.player.x = 50;
                this.player.y = 450;
                this.player.vx = 0;
                this.player.vy = 0;
                this.player.health = this.player.maxHealth;
                this.player.energy = this.player.maxEnergy;
                
                // Ground platform
                this.platforms.push(new Platform(0, 550, 1000, 50, '#334455'));
                
                // Generate random platforms
                const platformCount = 5 + Math.floor(this.endlessLevel / 2);
                for (let i = 0; i < platformCount; i++) {
                    const x = 100 + Math.random() * 700;
                    const y = 500 - (i * 70) - Math.random() * 30;
                    const width = 70 + Math.random() * 60;
                    this.platforms.push(new Platform(x, y, width, 20, '#445566'));
                }
                
                // Add some moving platforms
                if (this.endlessLevel > 2) {
                    const movingCount = 1 + Math.floor(this.endlessLevel / 4);
                    for (let i = 0; i < movingCount; i++) {
                        const x = 200 + Math.random() * 600;
                        const y = 200 + Math.random() * 200;
                        const horizontal = Math.random() > 0.5;
                        this.movingPlatforms.push(new MovingPlatform(
                            x, y, 80, 15, '#445566',
                            x, x + 150, y, y + 100, 2, horizontal
                        ));
                    }
                }
                
                // Add hazards
                if (this.endlessLevel > 1) {
                    const hazardCount = Math.floor(this.endlessLevel / 2);
                    for (let i = 0; i < hazardCount; i++) {
                        const x = 100 + Math.random() * 700;
                        const width = 30 + Math.random() * 40;
                        this.hazards.push(new Hazard(x, 530, width, 20, 'spike'));
                    }
                }
                
                // Generate enemies with scaling difficulty
                const enemyCount = 2 + Math.floor(this.endlessLevel * 0.8);
                for (let i = 0; i < enemyCount; i++) {
                    const x = 150 + Math.random() * 700;
                    const y = 500 - Math.random() * 300;
                    const rand = Math.random();
                    
                    if (rand < 0.3) {
                        this.enemies.push(new FastEnemy(x, y, 'shadow'));
                    } else if (rand < 0.6 && this.endlessLevel > 3) {
                        this.enemies.push(new TankEnemy(x, y, 'shadow'));
                    } else {
                        this.enemies.push(new Enemy(x, y, 'shadow'));
                    }
                }
                
                // Add mini-boss every 5 levels
                if (this.endlessLevel % 5 === 0) {
                    this.enemies.push(new MiniBoss(500, 300));
                }
                
                // Generate collectibles
                const orbCount = 3 + Math.floor(this.endlessLevel / 3);
                for (let i = 0; i < orbCount; i++) {
                    const x = 100 + Math.random() * 800;
                    const y = 200 + Math.random() * 300;
                    this.collectibles.push(new Orb(x, y));
                }
                
                // Always add a key to complete the level
                this.collectibles.push(new Key(800 + Math.random() * 100, 150 + Math.random() * 100));
                
                this.createParallaxLayers();
                this.updateUI();
                
                // Show endless mode info
                this.showTutorial(`Endless Level ${this.endlessLevel} - Difficulty: ${this.endlessDifficulty.toFixed(1)}x`, 2000);
            }
            
            // SHADOW REALM LEVELS (1-3)
            loadShadowRealm1() {
                // Tutorial level - Introduction to basic mechanics
                this.platforms.push(new Platform(0, 550, 1000, 50, '#334455'));
                this.platforms.push(new Platform(150, 450, 100, 20, '#445566'));
                this.platforms.push(new Platform(350, 380, 100, 20, '#445566'));
                this.platforms.push(new Platform(550, 310, 100, 20, '#445566'));
                this.platforms.push(new Platform(750, 240, 120, 20, '#445566'));
                
                // Easy enemies
                this.enemies.push(new Enemy(200, 500, 'shadow'));
                this.enemies.push(new Enemy(600, 260, 'shadow'));
                
                // Collectibles for energy and tutorial
                this.collectibles.push(new Orb(180, 420));
                this.collectibles.push(new Orb(380, 350));
                this.collectibles.push(new Orb(580, 280));
                this.collectibles.push(new Orb(800, 210));
                this.collectibles.push(new Key(850, 210));
            }
            
            loadShadowRealm2() {
                // Increased difficulty with more enemies
                this.platforms.push(new Platform(0, 550, 1000, 50, '#334455'));
                this.platforms.push(new Platform(120, 470, 80, 15, '#445566'));
                this.platforms.push(new Platform(260, 400, 90, 15, '#445566'));
                this.platforms.push(new Platform(400, 330, 85, 15, '#445566'));
                this.platforms.push(new Platform(540, 260, 95, 15, '#445566'));
                this.platforms.push(new Platform(680, 190, 100, 15, '#445566'));
                this.platforms.push(new Platform(820, 140, 140, 15, '#445566'));
                
                // More enemies with varied placement
                this.enemies.push(new Enemy(180, 500, 'shadow'));
                this.enemies.push(new Enemy(320, 430, 'shadow'));
                this.enemies.push(new Enemy(460, 360, 'shadow'));
                this.enemies.push(new Enemy(600, 290, 'shadow'));
                this.enemies.push(new Enemy(740, 220, 'shadow'));
                
                // Environmental hazards (spikes)
                this.hazards = [];
                this.hazards.push(new Hazard(230, 530, 40, 20, 'spike'));
                this.hazards.push(new Hazard(500, 530, 50, 20, 'spike'));
                
                this.collectibles.push(new Orb(150, 440));
                this.collectibles.push(new Orb(290, 370));
                this.collectibles.push(new Orb(430, 300));
                this.collectibles.push(new Orb(570, 230));
                this.collectibles.push(new Orb(710, 160));
                this.collectibles.push(new Key(900, 110));
            }
            
            loadShadowRealm3() {
                // Challenge level with moving platforms
                this.platforms.push(new Platform(0, 550, 200, 50, '#334455'));
                this.platforms.push(new Platform(800, 550, 200, 50, '#334455'));
                
                // Create moving platforms
                this.movingPlatforms = [];
                this.movingPlatforms.push(new MovingPlatform(250, 480, 90, 15, '#445566', 250, 450, 2, true));
                this.movingPlatforms.push(new MovingPlatform(450, 380, 90, 15, '#445566', 450, 650, 2.5, true));
                this.movingPlatforms.push(new MovingPlatform(300, 280, 80, 15, '#445566', 300, 500, 2, true));
                this.movingPlatforms.push(new MovingPlatform(600, 200, 100, 15, '#445566', 600, 750, 3, true));
                
                // Tough enemies
                this.enemies.push(new Enemy(100, 500, 'shadow'));
                this.enemies.push(new Enemy(850, 500, 'shadow'));
                this.enemies.push(new FastEnemy(450, 380, 'shadow'));
                this.enemies.push(new FastEnemy(650, 200, 'shadow'));
                
                // Hazards
                this.hazards = [];
                this.hazards.push(new Hazard(210, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(770, 530, 30, 20, 'spike'));
                
                this.collectibles.push(new Orb(280, 450));
                this.collectibles.push(new Orb(480, 350));
                this.collectibles.push(new Orb(330, 250));
                this.collectibles.push(new Orb(630, 170));
                this.collectibles.push(new Key(700, 170));
            }
            
            // FOREST KINGDOM LEVELS (4-6)
            loadForestKingdom1() {
                // Introduction to forest biome
                this.platforms.push(new Platform(0, 550, 1000, 50, '#2d5a2d'));
                this.platforms.push(new Platform(100, 470, 90, 18, '#3d6a3d'));
                this.platforms.push(new Platform(250, 400, 100, 18, '#3d6a3d'));
                this.platforms.push(new Platform(400, 330, 110, 18, '#3d6a3d'));
                this.platforms.push(new Platform(560, 260, 100, 18, '#3d6a3d'));
                this.platforms.push(new Platform(720, 190, 120, 18, '#3d6a3d'));
                
                this.enemies.push(new Enemy(150, 440, 'forest'));
                this.enemies.push(new Enemy(320, 370, 'forest'));
                this.enemies.push(new Enemy(480, 300, 'forest'));
                this.enemies.push(new TankEnemy(620, 230, 'forest'));
                
                this.collectibles.push(new Orb(130, 440));
                this.collectibles.push(new Orb(280, 370));
                this.collectibles.push(new Orb(430, 300));
                this.collectibles.push(new Orb(590, 230));
                this.collectibles.push(new Orb(750, 160));
                this.collectibles.push(new Key(820, 160));
            }
            
            loadForestKingdom2() {
                // Vertical climbing challenge
                this.platforms.push(new Platform(0, 550, 300, 50, '#2d5a2d'));
                this.platforms.push(new Platform(700, 550, 300, 50, '#2d5a2d'));
                this.platforms.push(new Platform(350, 490, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(500, 430, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(350, 370, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(500, 310, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(350, 250, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(500, 190, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(650, 130, 150, 15, '#3d6a3d'));
                
                this.enemies.push(new Enemy(100, 500, 'forest'));
                this.enemies.push(new FastEnemy(380, 460, 'forest'));
                this.enemies.push(new FastEnemy(530, 400, 'forest'));
                this.enemies.push(new TankEnemy(750, 500, 'forest'));
                
                // Moving platforms
                this.movingPlatforms = [];
                this.movingPlatforms.push(new MovingPlatform(600, 340, 70, 15, '#3d6a3d', 300, 200, 0, 400, 2, false));
                
                this.hazards = [];
                this.hazards.push(new Hazard(310, 530, 40, 20, 'spike'));
                this.hazards.push(new Hazard(590, 530, 100, 20, 'spike'));
                
                this.collectibles.push(new Orb(380, 460));
                this.collectibles.push(new Orb(530, 400));
                this.collectibles.push(new Orb(380, 340));
                this.collectibles.push(new Orb(530, 280));
                this.collectibles.push(new Orb(700, 100));
                this.collectibles.push(new Key(750, 100));
            }
            
            loadForestKingdom3() {
                // Complex platforming with multiple paths
                this.platforms.push(new Platform(0, 550, 150, 50, '#2d5a2d'));
                this.platforms.push(new Platform(850, 550, 150, 50, '#2d5a2d'));
                
                // Upper path
                this.platforms.push(new Platform(180, 400, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(320, 330, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(460, 260, 80, 15, '#3d6a3d'));
                this.platforms.push(new Platform(600, 190, 100, 15, '#3d6a3d'));
                
                // Lower path
                this.platforms.push(new Platform(180, 500, 70, 15, '#3d6a3d'));
                this.platforms.push(new Platform(320, 480, 70, 15, '#3d6a3d'));
                this.platforms.push(new Platform(460, 460, 70, 15, '#3d6a3d'));
                this.platforms.push(new Platform(600, 440, 70, 15, '#3d6a3d'));
                this.platforms.push(new Platform(740, 420, 80, 15, '#3d6a3d'));
                
                this.enemies.push(new FastEnemy(210, 370, 'forest'));
                this.enemies.push(new FastEnemy(350, 300, 'forest'));
                this.enemies.push(new TankEnemy(210, 470, 'forest'));
                this.enemies.push(new TankEnemy(490, 430, 'forest'));
                this.enemies.push(new Enemy(900, 500, 'forest'));
                
                this.hazards = [];
                this.hazards.push(new Hazard(260, 530, 60, 20, 'spike'));
                this.hazards.push(new Hazard(540, 530, 80, 20, 'spike'));
                
                this.collectibles.push(new Orb(210, 370));
                this.collectibles.push(new Orb(350, 300));
                this.collectibles.push(new Orb(490, 230));
                this.collectibles.push(new Orb(630, 160));
                this.collectibles.push(new Orb(390, 450));
                this.collectibles.push(new Key(920, 490));
            }
            
            // CRYSTAL CAVES LEVELS (7-9)
            loadCrystalCaves1() {
                // Introduction to crystal biome with tougher enemies
                this.platforms.push(new Platform(0, 550, 1000, 50, '#442244'));
                this.platforms.push(new Platform(120, 470, 100, 22, '#553355'));
                this.platforms.push(new Platform(280, 390, 100, 22, '#553355'));
                this.platforms.push(new Platform(440, 310, 100, 22, '#553355'));
                this.platforms.push(new Platform(600, 230, 100, 22, '#553355'));
                this.platforms.push(new Platform(760, 150, 140, 22, '#553355'));
                
                this.enemies.push(new TankEnemy(160, 440, 'crystal'));
                this.enemies.push(new FastEnemy(320, 360, 'crystal'));
                this.enemies.push(new TankEnemy(480, 280, 'crystal'));
                this.enemies.push(new FastEnemy(640, 200, 'crystal'));
                
                this.hazards = [];
                this.hazards.push(new Hazard(240, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(400, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(560, 530, 30, 20, 'spike'));
                
                this.collectibles.push(new Orb(150, 440));
                this.collectibles.push(new Orb(310, 360));
                this.collectibles.push(new Orb(470, 280));
                this.collectibles.push(new Orb(630, 200));
                this.collectibles.push(new Orb(820, 120));
                this.collectibles.push(new Key(860, 120));
            }
            
            loadCrystalCaves2() {
                // Precision platforming challenge
                this.platforms.push(new Platform(0, 550, 100, 50, '#442244'));
                this.platforms.push(new Platform(900, 550, 100, 50, '#442244'));
                
                // Small precise platforms
                this.platforms.push(new Platform(130, 490, 60, 12, '#553355'));
                this.platforms.push(new Platform(230, 450, 60, 12, '#553355'));
                this.platforms.push(new Platform(330, 410, 60, 12, '#553355'));
                this.platforms.push(new Platform(430, 370, 60, 12, '#553355'));
                this.platforms.push(new Platform(530, 330, 60, 12, '#553355'));
                this.platforms.push(new Platform(630, 290, 60, 12, '#553355'));
                this.platforms.push(new Platform(730, 250, 60, 12, '#553355'));
                this.platforms.push(new Platform(820, 210, 80, 12, '#553355'));
                
                // Moving platforms
                this.movingPlatforms = [];
                this.movingPlatforms.push(new MovingPlatform(500, 500, 70, 12, '#553355', 500, 700, 2.5, true));
                this.movingPlatforms.push(new MovingPlatform(200, 180, 70, 12, '#553355', 200, 400, 3, true));
                
                this.enemies.push(new FastEnemy(160, 460, 'crystal'));
                this.enemies.push(new FastEnemy(360, 380, 'crystal'));
                this.enemies.push(new FastEnemy(560, 300, 'crystal'));
                this.enemies.push(new FastEnemy(760, 220, 'crystal'));
                
                this.hazards = [];
                this.hazards.push(new Hazard(110, 530, 800, 20, 'spike'));
                
                this.collectibles.push(new Orb(160, 460));
                this.collectibles.push(new Orb(360, 380));
                this.collectibles.push(new Orb(560, 300));
                this.collectibles.push(new Orb(760, 220));
                this.collectibles.push(new Key(850, 180));
            }
            
            loadCrystalCaves3() {
                // Final crystal cave gauntlet
                this.platforms.push(new Platform(0, 550, 200, 50, '#442244'));
                this.platforms.push(new Platform(800, 550, 200, 50, '#442244'));
                
                // Complex platform layout
                this.platforms.push(new Platform(220, 480, 80, 18, '#553355'));
                this.platforms.push(new Platform(350, 420, 70, 18, '#553355'));
                this.platforms.push(new Platform(470, 360, 80, 18, '#553355'));
                this.platforms.push(new Platform(600, 300, 70, 18, '#553355'));
                this.platforms.push(new Platform(720, 240, 80, 18, '#553355'));
                
                // Additional mid-level platforms
                this.platforms.push(new Platform(300, 520, 50, 15, '#553355'));
                this.platforms.push(new Platform(500, 500, 50, 15, '#553355'));
                this.platforms.push(new Platform(650, 480, 50, 15, '#553355'));
                
                // Mixed enemy types
                this.enemies.push(new TankEnemy(100, 500, 'crystal'));
                this.enemies.push(new FastEnemy(250, 450, 'crystal'));
                this.enemies.push(new TankEnemy(380, 390, 'crystal'));
                this.enemies.push(new FastEnemy(500, 330, 'crystal'));
                this.enemies.push(new TankEnemy(630, 270, 'crystal'));
                this.enemies.push(new FastEnemy(750, 210, 'crystal'));
                this.enemies.push(new TankEnemy(850, 500, 'crystal'));
                
                // Moving platforms
                this.movingPlatforms = [];
                this.movingPlatforms.push(new MovingPlatform(400, 200, 80, 15, '#553355', 300, 150, 0, 350, 2, false));
                
                this.hazards = [];
                this.hazards.push(new Hazard(210, 530, 40, 20, 'spike'));
                this.hazards.push(new Hazard(420, 530, 60, 20, 'spike'));
                this.hazards.push(new Hazard(560, 530, 50, 20, 'spike'));
                
                this.collectibles.push(new Orb(250, 450));
                this.collectibles.push(new Orb(380, 390));
                this.collectibles.push(new Orb(500, 330));
                this.collectibles.push(new Orb(630, 270));
                this.collectibles.push(new Orb(750, 210));
                this.collectibles.push(new Key(900, 490));
            }
            
            // BOSS ARENA LEVELS (10-12)
            loadBossArena1() {
                // Pre-boss gauntlet
                this.platforms.push(new Platform(0, 550, 1000, 50, '#552222'));
                this.platforms.push(new Platform(100, 470, 80, 18, '#663333'));
                this.platforms.push(new Platform(230, 410, 80, 18, '#663333'));
                this.platforms.push(new Platform(360, 350, 80, 18, '#663333'));
                this.platforms.push(new Platform(490, 290, 80, 18, '#663333'));
                this.platforms.push(new Platform(620, 350, 80, 18, '#663333'));
                this.platforms.push(new Platform(750, 410, 80, 18, '#663333'));
                this.platforms.push(new Platform(880, 470, 80, 18, '#663333'));
                
                // Elite enemies
                this.enemies.push(new TankEnemy(140, 440, 'boss'));
                this.enemies.push(new FastEnemy(270, 380, 'boss'));
                this.enemies.push(new TankEnemy(400, 320, 'boss'));
                this.enemies.push(new FastEnemy(530, 260, 'boss'));
                this.enemies.push(new TankEnemy(660, 320, 'boss'));
                this.enemies.push(new FastEnemy(790, 380, 'boss'));
                this.enemies.push(new TankEnemy(920, 440, 'boss'));
                
                this.hazards = [];
                this.hazards.push(new Hazard(190, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(330, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(570, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(710, 530, 30, 20, 'spike'));
                this.hazards.push(new Hazard(850, 530, 30, 20, 'spike'));
                
                this.collectibles.push(new Orb(140, 440));
                this.collectibles.push(new Orb(270, 380));
                this.collectibles.push(new Orb(400, 320));
                this.collectibles.push(new Orb(530, 260));
                this.collectibles.push(new Orb(660, 320));
                this.collectibles.push(new Key(920, 440));
            }
            
            loadBossArena2() {
                // Mini-boss battle
                this.platforms.push(new Platform(0, 550, 1000, 50, '#552222'));
                this.platforms.push(new Platform(100, 450, 100, 20, '#663333'));
                this.platforms.push(new Platform(300, 380, 120, 20, '#663333'));
                this.platforms.push(new Platform(500, 320, 140, 20, '#663333'));
                this.platforms.push(new Platform(700, 380, 120, 20, '#663333'));
                this.platforms.push(new Platform(850, 450, 100, 20, '#663333'));
                
                // Mini-boss
                this.enemies.push(new MiniBoss(500, 250));
                
                // Support enemies
                this.enemies.push(new FastEnemy(150, 420, 'boss'));
                this.enemies.push(new FastEnemy(850, 420, 'boss'));
                
                this.collectibles.push(new Orb(150, 420));
                this.collectibles.push(new Orb(350, 350));
                this.collectibles.push(new Orb(750, 350));
                this.collectibles.push(new Orb(900, 420));
                this.collectibles.push(new Key(550, 290));
            }
            
            loadFinalBoss() {
                // Final boss arena
                this.platforms.push(new Platform(0, 550, 1000, 50, '#552222'));
                this.platforms.push(new Platform(80, 450, 90, 20, '#663333'));
                this.platforms.push(new Platform(250, 380, 100, 20, '#663333'));
                this.platforms.push(new Platform(450, 320, 110, 20, '#663333'));
                this.platforms.push(new Platform(650, 380, 100, 20, '#663333'));
                this.platforms.push(new Platform(830, 450, 90, 20, '#663333'));
                
                // Shadow King final form
                this.enemies.push(new ShadowKing(500, 200));
                
                this.collectibles.push(new Orb(120, 420));
                this.collectibles.push(new Orb(290, 350));
                this.collectibles.push(new Orb(490, 290));
                this.collectibles.push(new Orb(690, 350));
                this.collectibles.push(new Orb(870, 420));
                this.collectibles.push(new Key(530, 290));
            }
            
            update(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                // Update player
                this.player.update(this.keys, deltaTime);
                
                // Update moving platforms
                for (let platform of this.movingPlatforms) {
                    platform.update(deltaTime);
                }
                
                // Check platform collisions
                this.checkPlatformCollisions();
                
                // Check hazard collisions
                for (let hazard of this.hazards) {
                    if (this.checkCollision(this.player, hazard) && !this.player.invulnerable) {
                        this.player.takeDamage(30);
                        this.addFloatingText('-30', this.player.x + this.player.width/2, this.player.y, '#ff3333', 18);
                        this.addScreenShake(5);
                    }
                }
                
                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(deltaTime);
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, enemy)) {
                        if (this.player.isGroundSlamming && this.player.vy > 0) {
                            // Player defeats enemy with ground slam
                            this.enemies.splice(i, 1);
                            this.addParticleExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff6666');
                            this.addScreenShake(5);
                            
                            // Combo system
                            this.combo++;
                            this.comboTimer = 3000; // 3 seconds to continue combo
                            this.comboMultiplier = Math.min(1 + (this.combo * 0.2), 3); // Max 3x multiplier
                            
                            const points = Math.floor(100 * this.comboMultiplier);
                            this.score += points;
                            
                            const comboText = this.combo > 1 ? ` x${this.combo}!` : '';
                            this.addFloatingText(`+${points}${comboText}`, enemy.x + enemy.width/2, enemy.y, '#ffdd00', 20);
                            this.playSound('enemy_defeat');
                            
                            // Combo achievement
                            if (this.combo >= 5) this.checkAchievement('combo_master', 'Combo Master! 5 in a row!');
                            
                            // Achievement check
                            if (enemy instanceof ShadowKing) {
                                this.checkAchievement('defeat_boss', 'Shadow King Defeated!');
                            }
                        } else if (!this.player.invulnerable) {
                            // Player takes damage
                            this.player.takeDamage(25);
                            this.addFloatingText('-25', this.player.x + this.player.width/2, this.player.y, '#ff4444', 18);
                            this.addScreenShake(3);
                            this.playSound('hit');
                        }
                    }
                }
                
                // Update collectibles
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    if (this.checkCollision(this.player, collectible)) {
                        if (collectible instanceof Orb) {
                            this.player.energy = Math.min(this.player.maxEnergy, this.player.energy + 20);
                            this.score += 50;
                            this.addFloatingText('+50', collectible.x + collectible.width/2, collectible.y, '#ffdd00', 16);
                        } else if (collectible instanceof Key) {
                            this.player.health = Math.min(this.player.maxHealth, this.player.health + 25);
                            this.score += 200;
                            this.addFloatingText('+200', collectible.x + collectible.width/2, collectible.y, '#00ff88', 20);
                        }
                        
                        this.collectibles.splice(i, 1);
                        this.addParticleBurst(collectible.x + collectible.width/2, collectible.y + collectible.height/2, collectible.color);
                        this.playSound('collect');
                    }
                }
                
                // Update camera
                this.updateCamera();
                
                // Update particles
                this.updateParticles(deltaTime);
                
                // Update floating texts
                this.updateFloatingTexts(deltaTime);
                
                // Update parallax layers
                this.updateParallaxLayers();
                
                // Update combo system
                if (this.comboTimer > 0) {
                    this.comboTimer -= deltaTime;
                    if (this.comboTimer <= 0) {
                        this.combo = 0;
                        this.comboMultiplier = 1;
                    }
                }
                
                // Update screen shake
                if (this.screenShake.intensity > 0) {
                    this.screenShake.x = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.y = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.intensity *= 0.9;
                    if (this.screenShake.intensity < 0.1) {
                        this.screenShake.intensity = 0;
                        this.screenShake.x = 0;
                        this.screenShake.y = 0;
                    }
                }
                
                // Check level completion
                if (this.collectibles.filter(c => c instanceof Key).length === 0) {
                    // Achievement checks
                    if (this.currentLevel === 3) this.checkAchievement('complete_shadow', 'Shadow Realm Complete!');
                    if (this.currentLevel === 6) this.checkAchievement('complete_forest', 'Forest Kingdom Complete!');
                    if (this.currentLevel === 9) this.checkAchievement('complete_crystal', 'Crystal Caves Complete!');
                    if (this.player.health === this.player.maxHealth) this.checkAchievement('no_damage', 'Flawless Victory!');
                    
                    this.completeLevel();
                }
                
                // Check game over
                if (this.player.health <= 0) {
                    this.gameOver();
                }
                
                this.updateUI();
            }
            
            checkPlatformCollisions() {
                this.player.grounded = false;
                
                // Check static platforms
                const allPlatforms = [...this.platforms, ...this.movingPlatforms];
                for (let platform of allPlatforms) {
                    if (this.checkCollision(this.player, platform)) {
                        // Calculate overlap
                        const overlapX = Math.min(
                            this.player.x + this.player.width - platform.x,
                            platform.x + platform.width - this.player.x
                        );
                        const overlapY = Math.min(
                            this.player.y + this.player.height - platform.y,
                            platform.y + platform.height - this.player.y
                        );
                        
                        if (overlapX < overlapY) {
                            // Horizontal collision
                            if (this.player.x < platform.x) {
                                this.player.x = platform.x - this.player.width;
                            } else {
                                this.player.x = platform.x + platform.width;
                            }
                            this.player.vx = 0;
                        } else {
                            // Vertical collision
                            if (this.player.y < platform.y) {
                                // Landing on platform
                                this.player.y = platform.y - this.player.height;
                                this.player.vy = 0;
                                this.player.grounded = true;
                                this.player.jumpsRemaining = this.player.maxJumps;
                                
                                // Ground slam effect
                                if (this.player.isGroundSlamming) {
                                    this.player.isGroundSlamming = false;
                                    this.addScreenShake(8);
                                    this.addParticleExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height, '#ffaa44');
                                }
                            } else {
                                // Hitting platform from below
                                this.player.y = platform.y + platform.height;
                                this.player.vy = 0;
                            }
                        }
                    }
                }
            }
            
            updateCamera() {
                // Improved camera with deadzone
                const targetX = this.player.x - this.width / 2;
                const targetY = this.player.y - this.height / 2;
                
                // Only move camera if player is outside deadzone
                const deltaX = targetX - this.camera.x;
                const deltaY = targetY - this.camera.y;
                
                if (Math.abs(deltaX) > this.camera.deadzone / 2) {
                    this.camera.x += deltaX * 0.08;
                }
                if (Math.abs(deltaY) > this.camera.deadzone / 2) {
                    this.camera.y += deltaY * 0.08;
                }
                
                // Clamp camera
                this.camera.x = Math.max(0, Math.min(this.camera.x, 1000 - this.width));
                this.camera.y = Math.max(-200, Math.min(this.camera.y, 0));
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            addParticleBurst(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        life: 500,
                        maxLife: 500,
                        color: color,
                        size: 3
                    });
                }
            }
            
            addParticleExplosion(x, y, color) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 2,
                        life: 800,
                        maxLife: 800,
                        color: color,
                        size: 4
                    });
                }
            }
            
            addParticleTrail(x, y, color) {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 300,
                    maxLife: 300,
                    color: color,
                    size: 2
                });
            }
            
            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2; // gravity
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            addScreenShake(intensity) {
                this.screenShake.intensity = Math.max(this.screenShake.intensity, intensity);
            }
            
            addFloatingText(text, x, y, color, size) {
                this.floatingTexts.push({
                    text: text,
                    x: x,
                    y: y,
                    vy: -2,
                    life: 1000,
                    maxLife: 1000,
                    color: color,
                    size: size
                });
            }
            
            updateFloatingTexts(deltaTime) {
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const text = this.floatingTexts[i];
                    text.y += text.vy;
                    text.vy += 0.05; // Slight deceleration
                    text.life -= deltaTime;
                    
                    if (text.life <= 0) {
                        this.floatingTexts.splice(i, 1);
                    }
                }
            }
            
            createParallaxLayers() {
                this.parallaxLayers = [];
                
                // Get biome-specific colors
                const biomeIdx = Math.ceil(this.currentLevel / 3);
                const layerConfigs = {
                    1: [ // Shadow Realm
                        { color: '#001122', speed: 0.1, alpha: 0.3 },
                        { color: '#002244', speed: 0.3, alpha: 0.4 },
                        { color: '#003366', speed: 0.5, alpha: 0.5 }
                    ],
                    2: [ // Forest Kingdom
                        { color: '#001100', speed: 0.1, alpha: 0.3 },
                        { color: '#002200', speed: 0.3, alpha: 0.4 },
                        { color: '#003300', speed: 0.5, alpha: 0.5 }
                    ],
                    3: [ // Crystal Caves
                        { color: '#110011', speed: 0.1, alpha: 0.3 },
                        { color: '#220022', speed: 0.3, alpha: 0.4 },
                        { color: '#330033', speed: 0.5, alpha: 0.5 }
                    ],
                    4: [ // Boss Arena
                        { color: '#110000', speed: 0.1, alpha: 0.3 },
                        { color: '#220000', speed: 0.3, alpha: 0.4 },
                        { color: '#330000', speed: 0.5, alpha: 0.5 }
                    ]
                };
                
                const configs = layerConfigs[biomeIdx] || layerConfigs[1];
                for (let config of configs) {
                    this.parallaxLayers.push({
                        particles: this.generateParallaxParticles(20),
                        speed: config.speed,
                        color: config.color,
                        alpha: config.alpha
                    });
                }
            }
            
            generateParallaxParticles(count) {
                const particles = [];
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: Math.random() * 1500,
                        y: Math.random() * 600,
                        size: Math.random() * 3 + 1,
                        vx: (Math.random() - 0.5) * 0.5
                    });
                }
                return particles;
            }
            
            updateParallaxLayers() {
                for (let layer of this.parallaxLayers) {
                    for (let particle of layer.particles) {
                        particle.x += particle.vx;
                        
                        // Wrap around
                        if (particle.x < -10) particle.x = 1510;
                        if (particle.x > 1510) particle.x = -10;
                    }
                }
            }
            
            completeLevel() {
                // Save progress
                this.saveProgress();
                this.playSound('levelComplete');
                
                if (this.currentLevel < this.maxLevel) {
                    this.gameState = 'levelComplete';
                    document.getElementById('levelCompleteScreen').classList.remove('hidden');
                    const levelNames = ['', 
                        'Shadow Realm 1', 'Shadow Realm 2', 'Shadow Realm 3',
                        'Forest Kingdom 1', 'Forest Kingdom 2', 'Forest Kingdom 3',
                        'Crystal Caves 1', 'Crystal Caves 2', 'Crystal Caves 3',
                        'Boss Arena 1', 'Boss Arena 2', 'Final Boss'];
                    document.getElementById('levelCompleteText').textContent = `Moving to ${levelNames[this.currentLevel + 1]}...`;
                } else {
                    this.victory();
                }
            }
            
            victory() {
                this.gameState = 'victory';
                
                // Update high score
                const isNewHighScore = this.score > this.highScore;
                if (isNewHighScore) {
                    this.highScore = this.score;
                    localStorage.setItem('echoRealmsHighScore', this.highScore);
                }
                
                // Check achievements
                this.checkAchievement('complete_game', 'Game Completed!');
                if (this.score > 5000) this.checkAchievement('high_score', 'Score Master!');
                
                // Update victory screen
                document.getElementById('finalScore').textContent = `Final Score: ${this.score}`;
                document.getElementById('highScoreDisplay').textContent = isNewHighScore 
                    ? `🎉 NEW HIGH SCORE! 🎉` 
                    : `High Score: ${this.highScore}`;
                
                document.getElementById('victoryScreen').classList.remove('hidden');
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
            
            saveProgress() {
                const progress = {
                    currentLevel: this.currentLevel,
                    highScore: this.highScore,
                    score: this.score
                };
                localStorage.setItem('echoRealmsProgress', JSON.stringify(progress));
            }
            
            loadProgress() {
                const saved = localStorage.getItem('echoRealmsProgress');
                if (saved) {
                    const progress = JSON.parse(saved);
                    return progress;
                }
                return null;
            }
            
            checkAchievement(id, name) {
                if (!this.achievements.includes(id)) {
                    this.achievements.push(id);
                    localStorage.setItem('echoRealmsAchievements', JSON.stringify(this.achievements));
                    this.showAchievementNotification(name);
                }
            }
            
            showAchievementNotification(name) {
                // Create achievement popup
                const popup = document.createElement('div');
                popup.style.position = 'fixed';
                popup.style.top = '80px';
                popup.style.right = '20px';
                popup.style.background = 'rgba(0, 200, 100, 0.9)';
                popup.style.color = 'white';
                popup.style.padding = '15px 20px';
                popup.style.borderRadius = '8px';
                popup.style.fontFamily = 'monospace';
                popup.style.zIndex = '2000';
                popup.style.boxShadow = '0 4px 15px rgba(0,0,0,0.5)';
                popup.innerHTML = `<strong>🏆 Achievement!</strong><br>${name}`;
                document.body.appendChild(popup);
                
                setTimeout(() => {
                    popup.style.transition = 'opacity 0.5s';
                    popup.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(popup), 500);
                }, 3000);
            }
            
            updateUI() {
                // Health bar
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.querySelector('#healthBar .bar-fill').style.width = healthPercent + '%';
                
                // Energy bar
                const energyPercent = (this.player.energy / this.player.maxEnergy) * 100;
                document.querySelector('#energyBar .bar-fill').style.width = energyPercent + '%';
                
                // Stats
                document.getElementById('level').textContent = this.currentLevel;
                document.getElementById('orbs').textContent = this.collectibles.filter(c => c instanceof Orb).length;
                document.getElementById('score').textContent = this.score;
                
                // Combo display
                const comboDisplay = document.getElementById('comboDisplay');
                if (this.combo > 1) {
                    comboDisplay.style.display = 'block';
                    document.getElementById('combo').textContent = this.combo;
                } else {
                    comboDisplay.style.display = 'none';
                }
            }
            
            render() {
                // Clear canvas with biome background
                const biomeColors = {
                    1: ['#001a33', '#002266'], 2: ['#001a33', '#002266'], 3: ['#001a33', '#002266'], // Shadow Realm
                    4: ['#001a00', '#003300'], 5: ['#001a00', '#003300'], 6: ['#001a00', '#003300'], // Forest Kingdom
                    7: ['#1a001a', '#330033'], 8: ['#1a001a', '#330033'], 9: ['#1a001a', '#330033'], // Crystal Caves
                    10: ['#1a0000', '#330000'], 11: ['#1a0000', '#330000'], 12: ['#1a0000', '#330000'] // Boss Arena
                };
                
                const colors = biomeColors[this.currentLevel] || biomeColors[1];
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(1, colors[1]);
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                if (this.gameState !== 'playing') return;
                
                // Render parallax background layers
                for (let layer of this.parallaxLayers) {
                    this.ctx.save();
                    this.ctx.globalAlpha = layer.alpha;
                    this.ctx.translate(-this.camera.x * layer.speed, -this.camera.y * layer.speed);
                    
                    for (let particle of layer.particles) {
                        this.ctx.fillStyle = layer.color;
                        this.ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                    }
                    this.ctx.restore();
                }
                
                // Apply camera and screen shake
                this.ctx.save();
                this.ctx.translate(-this.camera.x + this.screenShake.x, -this.camera.y + this.screenShake.y);
                
                // Render platforms
                for (let platform of this.platforms) {
                    platform.render(this.ctx);
                }
                
                // Render moving platforms
                for (let platform of this.movingPlatforms) {
                    platform.render(this.ctx);
                }
                
                // Render hazards
                for (let hazard of this.hazards) {
                    hazard.render(this.ctx);
                }
                
                // Render collectibles
                for (let collectible of this.collectibles) {
                    collectible.render(this.ctx);
                }
                
                // Render enemies
                for (let enemy of this.enemies) {
                    enemy.render(this.ctx);
                }
                
                // Render player
                this.player.render(this.ctx);
                
                // Render particles
                for (let particle of this.particles) {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
                    this.ctx.restore();
                }
                
                // Render floating texts
                for (let text of this.floatingTexts) {
                    const alpha = text.life / text.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = text.color;
                    this.ctx.font = `bold ${text.size}px monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(text.text, text.x, text.y);
                    this.ctx.fillText(text.text, text.x, text.y);
                    this.ctx.restore();
                }
                
                this.ctx.restore();
            }
            
            playSound(type) {
                if (!this.soundEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                const volume = this.settings.sfxVolume;
                gainNode.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime);
                
                switch(type) {
                    case 'jump':
                        oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                        oscillator.type = 'sine';
                        break;
                    case 'dash':
                        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.type = 'sawtooth';
                        break;
                    case 'collect':
                        oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                        oscillator.type = 'square';
                        break;
                    case 'hit':
                        oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.type = 'sawtooth';
                        break;
                    case 'enemy_defeat':
                        oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.3);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.type = 'triangle';
                        break;
                    case 'levelComplete':
                        oscillator.frequency.setValueAtTime(523, this.audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(659, this.audioContext.currentTime + 0.15);
                        oscillator.frequency.setValueAtTime(784, this.audioContext.currentTime + 0.3);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        oscillator.type = 'sine';
                        break;
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
            }
            
            showTutorial(message, duration = 4000) {
                if (!this.settings.showTutorial) return;
                
                const overlay = document.getElementById('tutorialOverlay');
                const text = document.getElementById('tutorialText');
                
                text.textContent = message;
                overlay.style.display = 'block';
                
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, duration);
            }
            
            checkTutorials() {
                if (this.currentLevel === 1 && !this.tutorialShown.welcome) {
                    this.tutorialShown.welcome = true;
                    setTimeout(() => this.showTutorial('Welcome to EchoRealms! Use WASD or Arrow keys to move. Collect all items to complete the level!'), 500);
                }
                
                if (this.player.jumpsRemaining < 3 && !this.tutorialShown.jump) {
                    this.tutorialShown.jump = true;
                    this.showTutorial('Great! You can jump up to 3 times in the air. Try it!');
                }
                
                if (this.enemies.length > 0 && !this.tutorialShown.enemy && this.currentLevel === 1) {
                    this.tutorialShown.enemy = true;
                    setTimeout(() => this.showTutorial('Watch out for enemies! Press S while in the air to Ground Slam them, or press X to dash through them!'), 3000);
                }
            }
            
            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                this.checkTutorials();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Player Class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 48;
                this.vx = 0;
                this.vy = 0;
                this.speed = 6;
                this.jumpPower = 16;
                this.maxJumps = 3;
                this.jumpsRemaining = this.maxJumps;
                this.grounded = false;
                
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.maxEnergy = 100;
                this.energy = this.maxEnergy;
                
                // Abilities
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.isGroundSlamming = false;
                this.dashCooldown = 0;
                this.timeSlowActive = false;
                this.timeSlowCooldown = 0;
                
                this.color = '#66ccff';
            }
            
            update(keys, deltaTime) {
                // Energy regeneration
                if (this.energy < this.maxEnergy) {
                    this.energy = Math.min(this.maxEnergy, this.energy + 0.3);
                }
                
                // Cooldowns
                if (this.dashCooldown > 0) this.dashCooldown -= deltaTime;
                if (this.timeSlowCooldown > 0) this.timeSlowCooldown -= deltaTime;
                if (this.invulnerabilityTime > 0) {
                    this.invulnerabilityTime -= deltaTime;
                    if (this.invulnerabilityTime <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                // Movement
                if (keys['a'] || keys['arrowleft']) {
                    this.vx = -this.speed;
                } else if (keys['d'] || keys['arrowright']) {
                    this.vx = this.speed;
                } else {
                    this.vx *= 0.8;
                }
                
                // Triple Jump
                if ((keys['w'] || keys['arrowup'] || keys[' ']) && this.jumpsRemaining > 0) {
                    if (!keys._jumpPressed) {
                        this.vy = -this.jumpPower;
                        this.jumpsRemaining--;
                        this.grounded = false;
                        keys._jumpPressed = true;
                        game.playSound('jump');
                        
                        // Jump particles
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            game.addParticleTrail(
                                this.x + this.width/2 + Math.cos(angle) * 15,
                                this.y + this.height + Math.sin(angle) * 15,
                                '#66ccff'
                            );
                        }
                    }
                } else {
                    keys._jumpPressed = false;
                }
                
                // Echo Dash
                if (keys['x'] && this.dashCooldown <= 0 && this.energy >= 25) {
                    if (!keys._dashPressed) {
                        const direction = keys['a'] || keys['arrowleft'] ? -1 : 1;
                        this.vx = direction * 15;
                        this.invulnerable = true;
                        this.invulnerabilityTime = 300;
                        this.energy -= 25;
                        this.dashCooldown = 1000;
                        keys._dashPressed = true;
                        game.playSound('dash');
                        
                        // Dash particles
                        for (let i = 0; i < 10; i++) {
                            game.addParticleTrail(
                                this.x + this.width/2,
                                this.y + this.height/2,
                                '#66ccff'
                            );
                        }
                    }
                } else {
                    keys._dashPressed = false;
                }
                
                // Time Slow
                if (keys['c'] && this.timeSlowCooldown <= 0 && this.energy >= 30) {
                    if (!keys._timeSlowPressed) {
                        this.timeSlowActive = true;
                        this.energy -= 30;
                        this.timeSlowCooldown = 2000;
                        keys._timeSlowPressed = true;
                    }
                } else {
                    keys._timeSlowPressed = false;
                    this.timeSlowActive = false;
                }
                
                // Ground Slam
                if ((keys['s'] || keys['arrowdown']) && !this.grounded && this.energy >= 20) {
                    if (!keys._slamPressed) {
                        this.vy = 20;
                        this.isGroundSlamming = true;
                        this.energy -= 20;
                        keys._slamPressed = true;
                    }
                } else {
                    keys._slamPressed = false;
                }
                
                // Gravity
                if (!this.grounded) {
                    this.vy += 0.8;
                }
                
                // Apply velocity with time slow
                const timeScale = this.timeSlowActive ? 0.3 : 1;
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                
                // Bounds
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > 1000) this.x = 1000 - this.width;
                if (this.y > 700) {
                    this.takeDamage(50); // Fall damage
                    this.y = 400;
                }
            }
            
            takeDamage(amount) {
                if (this.invulnerable) return;
                
                this.health = Math.max(0, this.health - amount);
                this.invulnerable = true;
                this.invulnerabilityTime = 1000;
            }
            
            render(ctx) {
                // Invulnerability flashing
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Time slow effect
                if (this.timeSlowActive) {
                    ctx.shadowColor = '#0066ff';
                    ctx.shadowBlur = 10;
                }
                
                // Player body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Eyes
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + 8, this.y + 12, 6, 6);
                ctx.fillRect(this.x + 18, this.y + 12, 6, 6);
                
                // Ground slam aura
                if (this.isGroundSlamming) {
                    ctx.strokeStyle = '#ffaa44';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                }
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        // Enemy Class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 36;
                this.vx = 2;
                this.direction = 1;
                this.type = type;
                this.health = 50;
                this.patrolRange = 150;
                this.startX = x;
                
                const colors = {
                    shadow: '#8844aa',
                    forest: '#44aa44',
                    crystal: '#aa44aa'
                };
                this.color = colors[type] || colors.shadow;
            }
            
            update(deltaTime) {
                // Patrol AI
                this.x += this.vx * this.direction;
                
                if (this.x < this.startX - this.patrolRange || this.x > this.startX + this.patrolRange) {
                    this.direction *= -1;
                }
                
                // Simple gravity
                this.y += 0.5;
                if (this.y > 520) this.y = 520;
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
                
                // Eyes
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x + 6, this.y + 8, 4, 4);
                ctx.fillRect(this.x + 18, this.y + 8, 4, 4);
            }
        }
        
        // Fast Enemy - Quick and agile
        class FastEnemy extends Enemy {
            constructor(x, y, type) {
                super(x, y, type);
                this.vx = 3.5;
                this.health = 30;
                this.width = 24;
                this.height = 32;
                this.patrolRange = 200;
            }
            
            render(ctx) {
                // Draw a sleeker, faster-looking enemy
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x + 4, this.y, 16, 28);
                ctx.fillRect(this.x, this.y + 8, 24, 16);
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 12;
                ctx.fillRect(this.x + 4, this.y, 16, 28);
                ctx.shadowBlur = 0;
                
                // Eyes
                ctx.fillStyle = '#ff6666';
                ctx.fillRect(this.x + 5, this.y + 6, 3, 3);
                ctx.fillRect(this.x + 16, this.y + 6, 3, 3);
            }
        }
        
        // Tank Enemy - Slow but tough
        class TankEnemy extends Enemy {
            constructor(x, y, type) {
                super(x, y, type);
                this.vx = 1;
                this.health = 100;
                this.width = 36;
                this.height = 44;
                this.patrolRange = 100;
            }
            
            render(ctx) {
                // Draw a bulkier, tougher enemy
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y + 4, 36, 36);
                ctx.fillRect(this.x + 6, this.y, 24, 40);
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8;
                ctx.fillRect(this.x, this.y + 4, 36, 36);
                ctx.shadowBlur = 0;
                
                // Eyes
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x + 8, this.y + 10, 5, 5);
                ctx.fillRect(this.x + 23, this.y + 10, 5, 5);
                
                // Health bar
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x, this.y - 8, 36, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x, this.y - 8, 36 * (this.health / 100), 4);
            }
        }
        
        // Mini-Boss
        class MiniBoss extends Enemy {
            constructor(x, y) {
                super(x, y, 'boss');
                this.width = 52;
                this.height = 64;
                this.health = 150;
                this.maxHealth = 150;
                this.color = '#cc4422';
                this.attackTimer = 0;
                this.vx = 1.5;
                this.patrolRange = 200;
            }
            
            update(deltaTime) {
                this.attackTimer += deltaTime;
                
                if (this.attackTimer > 2000) {
                    this.attack();
                    this.attackTimer = 0;
                }
                
                super.update(deltaTime);
            }
            
            attack() {
                // Create projectiles
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    game.addParticleExplosion(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        this.color
                    );
                }
                game.addScreenShake(4);
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
                
                // Eyes
                ctx.fillStyle = '#ff2222';
                ctx.fillRect(this.x + 10, this.y + 12, 6, 6);
                ctx.fillRect(this.x + 36, this.y + 12, 6, 6);
                
                // Health bar
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x - 10, this.y - 15, this.width + 20, 8);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 10, this.y - 15, (this.width + 20) * (this.health / this.maxHealth), 8);
            }
        }
        
        // Shadow King Boss
        class ShadowKing extends Enemy {
            constructor(x, y) {
                super(x, y, 'boss');
                this.width = 64;
                this.height = 80;
                this.health = 250;
                this.maxHealth = 250;
                this.color = '#aa2222';
                this.attackTimer = 0;
                this.phase = 1;
                this.vx = 1.2;
                this.patrolRange = 180;
            }
            
            update(deltaTime) {
                this.attackTimer += deltaTime;
                
                // Phase changes
                if (this.health < this.maxHealth * 0.66 && this.phase === 1) {
                    this.phase = 2;
                    this.color = '#cc4444';
                    this.vx = 1.8;
                } else if (this.health < this.maxHealth * 0.33 && this.phase === 2) {
                    this.phase = 3;
                    this.color = '#ff6666';
                    this.vx = 2.5;
                }
                
                // Attack patterns - more aggressive
                const attackRate = 1800 - (this.phase * 300);
                if (this.attackTimer > attackRate) {
                    this.attack();
                    this.attackTimer = 0;
                }
                
                super.update(deltaTime);
            }
            
            attack() {
                // Create shadow projectiles in multiple directions
                const projectileCount = this.phase + 4;
                for (let i = 0; i < projectileCount; i++) {
                    const angle = (Math.PI * 2 / projectileCount) * i;
                    game.addParticleExplosion(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        this.color
                    );
                }
                game.addScreenShake(3 + this.phase);
            }
            
            render(ctx) {
                super.render(ctx);
                
                // Boss health bar
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x - 20, this.y - 30, this.width + 40, 12);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 20, this.y - 30, (this.width + 40) * (this.health / this.maxHealth), 12);
                
                // Phase indicator
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px monospace';
                ctx.fillText(`Phase ${this.phase}`, this.x + 10, this.y - 35);
                
                // Crown
                ctx.fillStyle = '#ffdd00';
                ctx.fillRect(this.x + 20, this.y - 15, 24, 8);
                ctx.fillRect(this.x + 22, this.y - 20, 4, 8);
                ctx.fillRect(this.x + 30, this.y - 25, 4, 13);
                ctx.fillRect(this.x + 38, this.y - 20, 4, 8);
            }
        }
        
        // Moving Platform
        class MovingPlatform {
            constructor(x, y, width, height, color, minX, maxX, minY, maxY, speed, horizontal) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.minX = minX;
                this.maxX = maxX;
                this.minY = minY || y;
                this.maxY = maxY || y;
                this.speed = speed;
                this.horizontal = horizontal;
                this.direction = 1;
            }
            
            update(deltaTime) {
                if (this.horizontal) {
                    this.x += this.speed * this.direction;
                    if (this.x <= this.minX || this.x >= this.maxX) {
                        this.direction *= -1;
                    }
                } else {
                    this.y += this.speed * this.direction;
                    if (this.y <= this.minY || this.y >= this.maxY) {
                        this.direction *= -1;
                    }
                }
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Moving indicator
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                ctx.setLineDash([]);
            }
        }
        
        // Hazard (Spikes, etc.)
        class Hazard {
            constructor(x, y, width, height, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.color = '#ff3333';
            }
            
            render(ctx) {
                if (this.type === 'spike') {
                    ctx.fillStyle = this.color;
                    const spikeCount = Math.floor(this.width / 10);
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i * 10, this.y + this.height);
                        ctx.lineTo(this.x + i * 10 + 5, this.y);
                        ctx.lineTo(this.x + i * 10 + 10, this.y + this.height);
                        ctx.fill();
                    }
                    
                    // Glow
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.fillRect(this.x, this.y + this.height - 2, this.width, 2);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // Platform Class
        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            
            render(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Add highlight
                ctx.fillStyle = this.color + '44';
                ctx.fillRect(this.x, this.y, this.width, 3);
            }
        }
        
        // Orb Class
        class Orb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.color = '#ffdd44';
                this.glow = 0;
            }
            
            render(ctx) {
                this.glow += 0.05;
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10 + Math.sin(this.glow) * 5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // Key Class
        class Key {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 12;
                this.color = '#44ff44';
                this.glow = 0;
            }
            
            render(ctx) {
                this.glow += 0.08;
                
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15 + Math.sin(this.glow) * 8;
                ctx.fillStyle = this.color;
                
                // Key shape
                ctx.fillRect(this.x, this.y + 4, 12, 4);
                ctx.fillRect(this.x + 12, this.y, 4, 8);
                ctx.fillRect(this.x + 16, this.y + 2, 2, 2);
                ctx.fillRect(this.x + 16, this.y + 6, 2, 2);
                
                ctx.shadowBlur = 0;
            }
        }
        
        // Global functions
        let game;
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            game = new Game();
            game.endlessMode = false;
            game.gameState = 'playing';
        }
        
        function startEndlessMode() {
            document.getElementById('startScreen').classList.add('hidden');
            game = new Game();
            game.endlessMode = true;
            game.loadEndlessLevel();
            game.gameState = 'playing';
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            if (game.endlessMode) {
                game.endlessLevel = 0;
                game.endlessDifficulty = 1;
                game.loadEndlessLevel();
            } else {
                game.loadLevel(1);
            }
            game.score = 0;
            game.combo = 0;
            game.gameState = 'playing';
        }
        
        function nextLevel() {
            document.getElementById('levelCompleteScreen').classList.add('hidden');
            if (game.endlessMode) {
                game.loadEndlessLevel();
            } else {
                game.loadLevel(game.currentLevel + 1);
            }
            game.gameState = 'playing';
        }
        
        function openSettings() {
            game.gameState = 'paused';
            document.getElementById('settingsScreen').classList.remove('hidden');
            document.getElementById('settingsButton').style.display = 'none';
            
            // Load current settings
            document.getElementById('sfxVolumeSlider').value = game.settings.sfxVolume * 100;
            document.getElementById('sfxVolumeValue').textContent = Math.round(game.settings.sfxVolume * 100) + '%';
            document.getElementById('showTutorial').checked = game.settings.showTutorial;
        }
        
        function closeSettings() {
            document.getElementById('settingsScreen').classList.add('hidden');
            document.getElementById('settingsButton').style.display = 'block';
            if (game.currentLevel > 0) {
                game.gameState = 'playing';
            }
        }
        
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
                localStorage.removeItem('echoRealmsProgress');
                localStorage.removeItem('echoRealmsHighScore');
                localStorage.removeItem('echoRealmsAchievements');
                alert('Progress reset! Reloading game...');
                location.reload();
            }
        }
        
        // Settings event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const sfxSlider = document.getElementById('sfxVolumeSlider');
            const sfxValue = document.getElementById('sfxVolumeValue');
            const tutorialCheck = document.getElementById('showTutorial');
            
            sfxSlider.addEventListener('input', function() {
                const volume = this.value / 100;
                sfxValue.textContent = this.value + '%';
                if (game) {
                    game.settings.sfxVolume = volume;
                    game.soundEnabled = volume > 0;
                    localStorage.setItem('echoRealmsSettings', JSON.stringify(game.settings));
                }
            });
            
            tutorialCheck.addEventListener('change', function() {
                if (game) {
                    game.settings.showTutorial = this.checked;
                    localStorage.setItem('echoRealmsSettings', JSON.stringify(game.settings));
                }
            });
        });
    </script>
</body>
</html>