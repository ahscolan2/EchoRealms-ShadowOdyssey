// Advanced Movement Mechanics System
// Ultra-responsive controls with professional-grade platformer physics
// Designed for precise, satisfying player control

class AdvancedMovementSystem {
    constructor(scene, player) {
        this.scene = scene;
        this.player = player;
        
        // Movement constants
        this.PHYSICS = {
            ACCELERATION: 15,
            FRICTION: 0.87,
            AIR_CONTROL: 0.65,
            MAX_SPEED: 220,
            JUMP_POWER: 420,
            GRAVITY: 0.8,
            TERMINAL_VELOCITY: 500,
            COYOTE_TIME: 100,      // ms grace period for jumping
            JUMP_BUFFER_TIME: 150,  // ms buffer for jump inputs
            WALL_SLIDE_SPEED: 80,
            WALL_JUMP_POWER: { x: 180, y: 380 }
        };\n        
        // Input state tracking\n        this.inputState = {\n            left: false,\n            right: false,\n            jump: false,\n            jumpPressed: false,\n            jumpReleased: false,\n            jumpBuffered: false,\n            jumpBufferTimer: 0\n        };\n        
        // Movement state\n        this.movementState = {\n            grounded: false,\n            wasGrounded: false,\n            lastGroundedTime: 0,\n            wallSliding: false,\n            wallDirection: 0,\n            facingDirection: 1,\n            velocity: { x: 0, y: 0 },\n            acceleration: { x: 0, y: 0 }\n        };\n        
        // Jump system\n        this.jumpState = {\n            jumpsRemaining: 3,\n            maxJumps: 3,\n            jumpHeldTime: 0,\n            variableJumpActive: false,\n            wallJumpCooldown: 0\n        };\n        
        // Visual effects integration\n        this.particleSystem = scene.player.particleSystem;\n        this.lastMovementParticle = 0;\n        \n        this.setupInputHandling();\n        \n        console.log('ðŸŽ® Advanced Movement System initialized - Ultra-responsive controls ready!');\n    }\n    \n    setupInputHandling() {\n        // Enhanced input detection with proper key states\n        this.scene.input.keyboard.on('keydown', (event) => {\n            this.handleKeyDown(event.key.toLowerCase());\n        });\n        \n        this.scene.input.keyboard.on('keyup', (event) => {\n            this.handleKeyUp(event.key.toLowerCase());\n        });\n    }\n    \n    handleKeyDown(key) {\n        switch(key) {\n            case 'a':\n            case 'arrowleft':\n                this.inputState.left = true;\n                break;\n            case 'd':\n            case 'arrowright':\n                this.inputState.right = true;\n                break;\n            case 'w':\n            case 'arrowup':\n            case ' ':\n                if (!this.inputState.jump) {\n                    this.inputState.jumpPressed = true;\n                    this.inputState.jumpBuffered = true;\n                    this.inputState.jumpBufferTimer = this.PHYSICS.JUMP_BUFFER_TIME;\n                }\n                this.inputState.jump = true;\n                break;\n        }\n    }\n    \n    handleKeyUp(key) {\n        switch(key) {\n            case 'a':\n            case 'arrowleft':\n                this.inputState.left = false;\n                break;\n            case 'd':\n            case 'arrowright':\n                this.inputState.right = false;\n                break;\n            case 'w':\n            case 'arrowup':\n            case ' ':\n                this.inputState.jump = false;\n                this.inputState.jumpReleased = true;\n                this.jumpState.variableJumpActive = false;\n                break;\n        }\n    }\n    \n    update(deltaTime) {\n        this.updateInputBuffers(deltaTime);\n        this.updateGroundingState();\n        this.updateWallSliding();\n        this.updateHorizontalMovement(deltaTime);\n        this.updateJumping(deltaTime);\n        this.updateVerticalMovement(deltaTime);\n        this.applyVelocity();\n        this.updateVisualEffects(deltaTime);\n        this.resetInputFlags();\n    }\n    \n    updateInputBuffers(deltaTime) {\n        // Jump buffer countdown\n        if (this.inputState.jumpBufferTimer > 0) {\n            this.inputState.jumpBufferTimer -= deltaTime;\n            if (this.inputState.jumpBufferTimer <= 0) {\n                this.inputState.jumpBuffered = false;\n            }\n        }\n        \n        // Wall jump cooldown\n        if (this.jumpState.wallJumpCooldown > 0) {\n            this.jumpState.wallJumpCooldown -= deltaTime;\n        }\n    }\n    \n    updateGroundingState() {\n        this.movementState.wasGrounded = this.movementState.grounded;\n        this.movementState.grounded = this.player.body.touching.down;\n        \n        if (this.movementState.grounded) {\n            this.movementState.lastGroundedTime = performance.now();\n            this.jumpState.jumpsRemaining = this.jumpState.maxJumps;\n            \n            // Landing effect\n            if (!this.movementState.wasGrounded && Math.abs(this.movementState.velocity.y) > 200) {\n                this.createLandingEffect();\n            }\n        }\n    }\n    \n    updateWallSliding() {\n        const touchingWall = this.player.body.touching.left || this.player.body.touching.right;\n        const movingIntoWall = (this.player.body.touching.left && this.inputState.left) ||\n                              (this.player.body.touching.right && this.inputState.right);\n        \n        this.movementState.wallSliding = touchingWall && !this.movementState.grounded && \n                                        this.movementState.velocity.y > 0 && movingIntoWall;\n        \n        if (this.movementState.wallSliding) {\n            this.movementState.wallDirection = this.player.body.touching.left ? -1 : 1;\n            \n            // Limit wall slide speed\n            if (this.movementState.velocity.y > this.PHYSICS.WALL_SLIDE_SPEED) {\n                this.movementState.velocity.y = this.PHYSICS.WALL_SLIDE_SPEED;\n            }\n            \n            // Wall slide particles\n            if (Math.random() < 0.3) {\n                this.createWallSlideParticles();\n            }\n        }\n    }\n    \n    updateHorizontalMovement(deltaTime) {\n        const inputX = this.getHorizontalInput();\n        const controlFactor = this.movementState.grounded ? 1.0 : this.PHYSICS.AIR_CONTROL;\n        \n        if (inputX !== 0) {\n            // Accelerate in input direction\n            this.movementState.acceleration.x = inputX * this.PHYSICS.ACCELERATION * controlFactor;\n            this.movementState.facingDirection = inputX;\n            \n            // Update player visual direction\n            this.player.setFlipX(inputX < 0);\n        } else {\n            // Apply friction\n            const frictionFactor = this.movementState.grounded ? this.PHYSICS.FRICTION : 0.95;\n            this.movementState.velocity.x *= frictionFactor;\n            this.movementState.acceleration.x = 0;\n        }\n        \n        // Apply acceleration\n        this.movementState.velocity.x += this.movementState.acceleration.x;\n        \n        // Clamp to max speed\n        this.movementState.velocity.x = Math.max(\n            -this.PHYSICS.MAX_SPEED, \n            Math.min(this.PHYSICS.MAX_SPEED, this.movementState.velocity.x)\n        );\n        \n        // Movement particles\n        if (this.movementState.grounded && Math.abs(this.movementState.velocity.x) > 50) {\n            this.createMovementParticles();\n        }\n    }\n    \n    updateJumping(deltaTime) {\n        const canJump = this.canJump();\n        const wantsToJump = this.inputState.jumpPressed || this.inputState.jumpBuffered;\n        \n        if (wantsToJump && canJump) {\n            this.performJump();\n        }\n        \n        // Variable jump height\n        if (this.jumpState.variableJumpActive && this.inputState.jump) {\n            this.jumpState.jumpHeldTime += deltaTime;\n            \n            // Extend jump while held (up to limit)\n            if (this.jumpState.jumpHeldTime < 200 && this.movementState.velocity.y < 0) {\n                this.movementState.velocity.y -= 0.5;\n            }\n        }\n        \n        // Cancel jump if released early\n        if (this.inputState.jumpReleased && this.movementState.velocity.y < -50) {\n            this.movementState.velocity.y *= 0.5;\n            this.jumpState.variableJumpActive = false;\n        }\n    }\n    \n    canJump() {\n        const timeSinceGrounded = performance.now() - this.movementState.lastGroundedTime;\n        const coyoteTimeValid = timeSinceGrounded <= this.PHYSICS.COYOTE_TIME;\n        const hasJumpsRemaining = this.jumpState.jumpsRemaining > 0;\n        const canWallJump = this.movementState.wallSliding && this.jumpState.wallJumpCooldown <= 0;\n        \n        return (this.movementState.grounded || coyoteTimeValid || hasJumpsRemaining || canWallJump);\n    }\n    \n    performJump() {\n        let jumpPower = this.PHYSICS.JUMP_POWER;\n        let jumpType = 'normal';\n        \n        if (this.movementState.wallSliding) {\n            // Wall jump\n            this.performWallJump();\n            return;\n        }\n        \n        if (this.movementState.grounded || \n            performance.now() - this.movementState.lastGroundedTime <= this.PHYSICS.COYOTE_TIME) {\n            // Ground jump\n            jumpType = 'ground';\n            this.jumpState.jumpsRemaining = this.jumpState.maxJumps - 1;\n        } else {\n            // Air jump\n            jumpType = 'air';\n            jumpPower -= (this.jumpState.maxJumps - this.jumpState.jumpsRemaining) * 50;\n            this.jumpState.jumpsRemaining--;\n        }\n        \n        // Apply jump\n        this.movementState.velocity.y = -jumpPower;\n        this.jumpState.variableJumpActive = true;\n        this.jumpState.jumpHeldTime = 0;\n        \n        // Clear jump buffer\n        this.inputState.jumpPressed = false;\n        this.inputState.jumpBuffered = false;\n        \n        // Effects and feedback\n        this.createJumpEffect(jumpType);\n        this.playJumpSound(jumpType);\n        \n        console.log(`ðŸ¦˜ ${jumpType} jump executed - ${this.jumpState.jumpsRemaining} remaining`);\n    }\n    \n    performWallJump() {\n        const jumpDirection = -this.movementState.wallDirection;\n        \n        // Wall jump physics\n        this.movementState.velocity.x = jumpDirection * this.PHYSICS.WALL_JUMP_POWER.x;\n        this.movementState.velocity.y = -this.PHYSICS.WALL_JUMP_POWER.y;\n        \n        // Reset wall jump cooldown\n        this.jumpState.wallJumpCooldown = 200;\n        \n        // Reset air jumps\n        this.jumpState.jumpsRemaining = this.jumpState.maxJumps - 1;\n        \n        // Clear inputs\n        this.inputState.jumpPressed = false;\n        this.inputState.jumpBuffered = false;\n        \n        // Visual effects\n        this.createWallJumpEffect();\n        this.scene.cameras.main.shake(80, 0.01);\n        \n        console.log('ðŸ§— Wall jump executed!');\n    }\n    \n    updateVerticalMovement(deltaTime) {\n        // Apply gravity (reduced while wall sliding)\n        const gravityMultiplier = this.movementState.wallSliding ? 0.3 : 1.0;\n        this.movementState.velocity.y += this.PHYSICS.GRAVITY * gravityMultiplier;\n        \n        // Terminal velocity\n        this.movementState.velocity.y = Math.min(\n            this.PHYSICS.TERMINAL_VELOCITY, \n            this.movementState.velocity.y\n        );\n    }\n    \n    applyVelocity() {\n        // Apply calculated velocity to Phaser physics body\n        this.player.body.setVelocityX(this.movementState.velocity.x);\n        this.player.body.setVelocityY(this.movementState.velocity.y);\n        \n        // Sync our tracking with actual physics\n        this.movementState.velocity.x = this.player.body.velocity.x;\n        this.movementState.velocity.y = this.player.body.velocity.y;\n    }\n    \n    getHorizontalInput() {\n        let input = 0;\n        if (this.inputState.left) input -= 1;\n        if (this.inputState.right) input += 1;\n        return input;\n    }\n    \n    // ==========================================\n    // VISUAL EFFECTS INTEGRATION\n    // ==========================================\n    \n    createJumpEffect(jumpType) {\n        const jumpNumber = this.jumpState.maxJumps - this.jumpState.jumpsRemaining;\n        \n        // Different effects for different jump types\n        if (jumpType === 'ground') {\n            this.particleSystem.createEffect('jumpRing', this.player.x, this.player.y + 20, {\n                colors: [0x00FFFF, 0x88DDFF]\n            });\n        } else {\n            // Air jump - more dramatic with each jump\n            const airJumpColors = [\n                [0x00FFFF], // First air jump\n                [0x00FFFF, 0xFFFF00], // Second air jump\n                [0x00FFFF, 0xFFFF00, 0xFF00FF] // Third air jump\n            ];\n            \n            this.particleSystem.createEffect('jumpRing', this.player.x, this.player.y, {\n                count: 6 + jumpNumber * 2,\n                colors: airJumpColors[jumpNumber - 1] || airJumpColors[0]\n            });\n        }\n        \n        // Landing prediction marker\n        if (jumpType === 'ground') {\n            this.createLandingPredictor();\n        }\n    }\n    \n    createWallJumpEffect() {\n        const wallX = this.movementState.wallDirection < 0 ? \n            this.player.x - 5 : this.player.x + this.player.width + 5;\n        \n        // Wall impact particles\n        this.particleSystem.createEffect('hitSpark', wallX, this.player.y + 20, {\n            count: 8,\n            colors: [0x00FFFF, 0xFFFFFF, 0x88DDFF]\n        });\n        \n        // Direction indicator\n        const arrow = this.scene.add.triangle(\n            this.player.x + (this.movementState.wallDirection * -30),\n            this.player.y + 10,\n            0, 0, 12, 8, 12, -8,\n            0x00FFFF, 0.8\n        );\n        \n        this.scene.tweens.add({\n            targets: arrow,\n            x: arrow.x + (this.movementState.wallDirection * -50),\n            alpha: 0,\n            duration: 400,\n            onComplete: () => arrow.destroy()\n        });\n    }\n    \n    createLandingEffect() {\n        const impactForce = Math.abs(this.movementState.velocity.y);\n        \n        if (impactForce > 150) {\n            // Hard landing - big effect\n            this.particleSystem.createEffect('landingImpact', this.player.x, this.player.y + 40, {\n                count: Math.min(15, Math.floor(impactForce / 20)),\n                colors: [0xFFAA44, 0xFF8844, 0xFF6644]\n            });\n            \n            // Screen shake for very hard landings\n            if (impactForce > 300) {\n                this.scene.cameras.main.shake(100, 0.02);\n            }\n        } else {\n            // Soft landing - subtle effect\n            this.particleSystem.createEffect('jumpRing', this.player.x, this.player.y + 20, {\n                count: 4,\n                colors: [0x888888],\n                size: { min: 2, max: 4 }\n            });\n        }\n    }\n    \n    createMovementParticles() {\n        const now = performance.now();\n        if (now - this.lastMovementParticle < 150) return; // Throttle particles\n        \n        this.lastMovementParticle = now;\n        \n        // Speed-based particle intensity\n        const speed = Math.abs(this.movementState.velocity.x);\n        if (speed > 100) {\n            const particle = this.scene.add.circle(\n                this.player.x + Phaser.Math.Between(0, this.player.width),\n                this.player.y + this.player.height,\n                2, 0x666666, 0.6\n            );\n            \n            this.scene.tweens.add({\n                targets: particle,\n                alpha: 0,\n                y: particle.y + 15,\n                x: particle.x + Phaser.Math.Between(-10, 10),\n                duration: 400,\n                onComplete: () => particle.destroy()\n            });\n        }\n    }\n    \n    createWallSlideParticles() {\n        const wallX = this.movementState.wallDirection < 0 ? \n            this.player.x - 2 : this.player.x + this.player.width + 2;\n        \n        const particle = this.scene.add.circle(\n            wallX,\n            this.player.y + Phaser.Math.Between(10, 30),\n            1.5, 0x999999, 0.7\n        );\n        \n        this.scene.tweens.add({\n            targets: particle,\n            alpha: 0,\n            y: particle.y + 20,\n            duration: 600,\n            onComplete: () => particle.destroy()\n        });\n    }\n    \n    createLandingPredictor() {\n        // Predict where player will land and show subtle indicator\n        const landingX = this.player.x + (this.movementState.velocity.x * 0.5);\n        const landingY = this.findLandingY(landingX);\n        \n        if (landingY > 0) {\n            const predictor = this.scene.add.circle(landingX, landingY, 8, 0x00FFFF, 0.3);\n            \n            this.scene.tweens.add({\n                targets: predictor,\n                scaleX: 1.5,\n                scaleY: 0.5,\n                alpha: 0,\n                duration: 800,\n                onComplete: () => predictor.destroy()\n            });\n        }\n    }\n    \n    findLandingY(x) {\n        // Simple ground detection for landing prediction\n        // In a full implementation, this would raycast down\n        return 550; // Simplified for demo\n    }\n    \n    updateVisualEffects(deltaTime) {\n        // Speed lines when moving fast\n        if (Math.abs(this.movementState.velocity.x) > 180) {\n            this.createSpeedLines();\n        }\n        \n        // Wall slide visual feedback\n        if (this.movementState.wallSliding) {\n            this.updateWallSlideVisuals();\n        }\n    }\n    \n    createSpeedLines() {\n        if (Math.random() > 0.7) {\n            const line = this.scene.add.rectangle(\n                this.player.x + Phaser.Math.Between(-50, 50),\n                this.player.y + Phaser.Math.Between(-20, 20),\n                Phaser.Math.Between(20, 40),\n                2, 0x00FFFF, 0.6\n            );\n            \n            this.scene.tweens.add({\n                targets: line,\n                alpha: 0,\n                x: line.x - (this.movementState.velocity.x > 0 ? 60 : -60),\n                duration: 200,\n                onComplete: () => line.destroy()\n            });\n        }\n    }\n    \n    updateWallSlideVisuals() {\n        // Subtle wall glow effect\n        if (!this.wallGlow) {\n            const wallX = this.movementState.wallDirection < 0 ? \n                this.player.x - 10 : this.player.x + this.player.width + 10;\n            \n            this.wallGlow = this.scene.add.rectangle(\n                wallX, this.player.y + 20, 4, 40, 0x00FFFF, 0.4\n            );\n        }\n        \n        // Update wall glow position\n        if (this.wallGlow) {\n            this.wallGlow.y = this.player.y + 20;\n        }\n    }\n    \n    resetInputFlags() {\n        this.inputState.jumpPressed = false;\n        this.inputState.jumpReleased = false;\n        \n        // Clean up wall glow if not wall sliding\n        if (!this.movementState.wallSliding && this.wallGlow) {\n            this.wallGlow.destroy();\n            this.wallGlow = null;\n        }\n    }\n    \n    playJumpSound(jumpType) {\n        const jumpSounds = {\n            ground: { frequency: 220, detune: 0 },\n            air: { frequency: 330, detune: 100 },\n            wall: { frequency: 440, detune: 200 }\n        };\n        \n        const soundConfig = jumpSounds[jumpType] || jumpSounds.ground;\n        this.scene.playSound('jump', soundConfig);\n    }\n    \n    // ==========================================\n    // DEBUG & PERFORMANCE\n    // ==========================================\n    \n    getDebugInfo() {\n        return {\n            position: { x: Math.round(this.player.x), y: Math.round(this.player.y) },\n            velocity: { \n                x: Math.round(this.movementState.velocity.x), \n                y: Math.round(this.movementState.velocity.y) \n            },\n            state: {\n                grounded: this.movementState.grounded,\n                wallSliding: this.movementState.wallSliding,\n                jumpsRemaining: this.jumpState.jumpsRemaining\n            },\n            input: {\n                horizontal: this.getHorizontalInput(),\n                jump: this.inputState.jump,\n                jumpBuffered: this.inputState.jumpBuffered\n            }\n        };\n    }\n    \n    // Public methods for abilities to interact with movement\n    addVelocity(x, y) {\n        this.movementState.velocity.x += x;\n        this.movementState.velocity.y += y;\n    }\n    \n    setVelocity(x, y) {\n        this.movementState.velocity.x = x;\n        this.movementState.velocity.y = y;\n    }\n    \n    getVelocity() {\n        return { ...this.movementState.velocity };\n    }\n    \n    isGrounded() {\n        return this.movementState.grounded;\n    }\n    \n    isWallSliding() {\n        return this.movementState.wallSliding;\n    }\n}\n\n// ==========================================\n// ABILITY SYSTEM INTEGRATION\n// ==========================================\n\nclass AbilityMovementIntegration {\n    constructor(movementSystem) {\n        this.movement = movementSystem;\n        this.scene = movementSystem.scene;\n        this.player = movementSystem.player;\n    }\n    \n    echoDash(direction) {\n        // Enhanced dash with movement system integration\n        this.movement.setVelocity(direction * 350, -60);\n        \n        // Dash trail effect\n        this.movement.particleSystem.createEffect('dashTrail', this.player.x, this.player.y);\n        \n        // Temporary air control boost\n        const originalAirControl = this.movement.PHYSICS.AIR_CONTROL;\n        this.movement.PHYSICS.AIR_CONTROL = 0.9;\n        \n        this.scene.time.delayedCall(300, () => {\n            this.movement.PHYSICS.AIR_CONTROL = originalAirControl;\n        });\n        \n        // Screen effect\n        this.scene.cameras.main.shake(100, 0.015);\n        \n        return true;\n    }\n    \n    groundSlam() {\n        if (this.movement.isGrounded()) return false;\n        \n        // Powerful downward slam\n        this.movement.setVelocity(0, 600);\n        \n        // Visual indicator\n        this.createSlamIndicator();\n        \n        return true;\n    }\n    \n    createSlamIndicator() {\n        const indicator = this.scene.add.circle(\n            this.player.x, this.player.y + 60, 15, 0xFF4500, 0.6\n        );\n        \n        this.scene.tweens.add({\n            targets: indicator,\n            scaleX: 2,\n            scaleY: 0.5,\n            alpha: 0,\n            duration: 400,\n            onComplete: () => indicator.destroy()\n        });\n    }\n    \n    timeSlow(active) {\n        if (active) {\n            // Reduce movement speeds for dramatic effect\n            this.movement.PHYSICS.ACCELERATION *= 0.7;\n            this.movement.PHYSICS.MAX_SPEED *= 0.8;\n            \n            // Time slow aura\n            this.movement.particleSystem.createEffect('timeSlowAura', \n                this.player.x, this.player.y);\n        } else {\n            // Restore normal speeds\n            this.movement.PHYSICS.ACCELERATION /= 0.7;\n            this.movement.PHYSICS.MAX_SPEED /= 0.8;\n        }\n    }\n}\n\n// Export for integration with main game\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { \n        AdvancedMovementSystem, \n        AbilityMovementIntegration \n    };\n}"